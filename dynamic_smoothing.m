function [smoothed_post_prob] = dynamic_smoothing(post_probabilities, trial_labels, alpha, beta)
%[smoothed_post_prob] = dynamic_smoothing(post_probabilities, trial_labels, alpha)
%	Applies evidence accumulation with dynamic smoothing (for binary classification)
%   Input arguments:
%       -post_probabilities: [samples x num_classes] matrix of probabilities
%           generated by a (binary) classificator
%       -trial_labels: vector of indices [samples x 1], which indicates for each
%        sample the corresponding trial (MI task) [11...1122...22...]
%        (without zeros)   
%       -inial_value: starting value for the smoothing for each trial
%
%   Output arguments:
%       -smoothed_post_prob: [samples x 1] matrix containing the result of
%       the application of dynamic smoothing on the input's posterior
%       probabilities (dividing each trial)
%       Values are in [0, 1]
%
%       First class: values tending to 1
%       Second class: values tending to 0
%       Undecided: in the middle
%            
%       Note: the function will only consider the first class' posterior
%       probabilities, see the lessons' slides for details   
    trial_labels = trial_labels(trial_labels ~= 0); %just to be sure
    
    smoothed_post_prob = zeros(size(post_probabilities, 1), 1);
    sample_offset = 0;
    
    num_trials = max(trial_labels);
        for trial_n = min(trial_labels):num_trials
        curr_trial_post_prob = post_probabilities(trial_labels == trial_n, :);
        
        if(isempty(curr_trial_post_prob))
            continue
        end
  
        smoothed_post_prob(sample_offset+1,1) = 0.5;
        
        for j = 2:size(curr_trial_post_prob)
            delta = alpha * f_free_val(0.8, smoothed_post_prob(sample_offset+j-1,1));
            delta = delta + (1-alpha)*f_bmi_val(curr_trial_post_prob(j,1));
            smoothed_post_prob(sample_offset+j,1) = max(min(smoothed_post_prob(sample_offset+j-1,1) +beta*delta, 1),0);
        end
        
        sample_offset = sample_offset + j;
    end
    
end

function [y] = f_free_val(conservative_amp, x)

    if (x <= 0.3)
        y = -sin(pi*x/0.3);
    else
        if (x >= 0.7)
            y = sin(pi*(x-0.7)/0.3);
        else
            y = conservative_amp * sin((1./0.2)*pi*(x-0.3));
        end
    end
        
end

function [y] = f_bmi_val(x)
    %y = (asin(2*x +0.5)./asin(1));
    y = (asin(2*(x -0.5))./asin(1)).*(0.5*(1+cos(2*pi*x)));
end